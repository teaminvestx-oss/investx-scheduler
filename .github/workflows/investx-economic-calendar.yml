name: InvestX Economic Calendar

on:
  schedule:
    - cron: "0 11 * * 1"   # Lunes 13:00 Madrid (11:00 UTC) ‚Äî semanal
    - cron: "0 11 * * 2-5" # Mar‚ÄìVie 13:00 Madrid (11:00 UTC) ‚Äî diario
  workflow_dispatch:

jobs:
  econ-calendar:
    runs-on: ubuntu-latest
    steps:
      # ----- deps -----
      - name: Install jq & pup
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y jq curl unzip
          curl -sL https://github.com/ericchiang/pup/releases/download/v0.4.0/pup_v0.4.0_linux_amd64.zip -o pup.zip
          unzip -o pup.zip
          sudo mv pup /usr/local/bin/

      # ----- 1) Obtener cookies + HTML base -----
      - name: Seed cookies & base HTML
        run: |
          set -e
          UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36"
          for URL in "https://es.investing.com/economic-calendar/" "https://www.investing.com/economic-calendar/"; do
            curl -sSL "$URL" \
              -H "User-Agent: $UA" \
              -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \
              -c cookies.txt -b cookies.txt -o /dev/null || true
          done

          # ----- 2) AJAX endpoint (actualizado: arrays + campos obligatorios) -----
      - name: Try AJAX endpoint (preferred)
        run: |
          set -euo pipefail
          UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36"
          FROM=$(TZ=Europe/Madrid date -d "monday this week" +%Y-%m-%d)
          TO=$(TZ=Europe/Madrid date -d "sunday this week" +%Y-%m-%d)

          # NOTA: country[]=5  (USA), importance[]=2,3 ; timeZone=55 ~ Madrid (CEST/CET en Investing)
          curl -sSL 'https://www.investing.com/economic-calendar/Service/getCalendarFilteredData' \
            -H "User-Agent: $UA" \
            -H 'Accept: application/json, text/javascript, */*; q=0.01' \
            -H 'Content-Type: application/x-www-form-urlencoded; charset=UTF-8' \
            -H 'X-Requested-With: XMLHttpRequest' \
            -H 'Origin: https://www.investing.com' \
            -H 'Referer: https://www.investing.com/economic-calendar/' \
            -b cookies.txt -c cookies.txt \
            --data "country[]=5&importance[]=2&importance[]=3&timeZone=55&timeFilter=time_only&currentTab=custom&limit_from=0&dateFrom=${FROM}&dateTo=${TO}&action=filter" \
            -o ajax.json || echo '{}' > ajax.json

          # La API devuelve {"data":"<tr>...</tr>"} o HTML directo
          if jq -e '.data' ajax.json >/dev/null 2>&1; then
            jq -r '.data' ajax.json > ajax_data.html
          else
            # Puede venir HTML plano
            cp ajax.json ajax_data.html || true
          fi

          # Extraer filas <tr id="eventRowId_...">
          if [ -s ajax_data.html ]; then
            pup 'tr[id^="eventRowId_"] json{}' < ajax_data.html > rows.json || echo "[]" > rows.json
          else
            echo "[]" > rows.json
          fi
          echo "AJAX rows count: $(jq 'length' rows.json)"

      # ----- 3) Fallback: HTML completo (ES/EN) si no hubo filas -----
      - name: Fallback to full HTML
        if: ${{ always() }}
        run: |
          set -euo pipefail
          COUNT=$(jq 'length' rows.json || echo 0)
          if [ "$COUNT" -gt 0 ]; then
            echo "Saltamos fallback: ya hay filas desde AJAX."
            exit 0
          fi

          UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36"
          for SRC in "https://es.investing.com/economic-calendar/" "https://www.investing.com/economic-calendar/"; do
            curl -sSL "$SRC" -H "User-Agent: $UA" -b cookies.txt -c cookies.txt -o cal.html || true
            pup 'tr[id^="eventRowId_"] json{}' < cal.html > rows_try.json || echo "[]" > rows_try.json
            if [ -s rows_try.json ] && [ "$(jq 'length' rows_try.json)" -gt 0 ]; then
              mv rows_try.json rows.json
              break
            fi
          done
          if [ ! -s rows.json ]; then echo "[]" > rows.json; fi
          echo "Fallback rows count: $(jq 'length' rows.json)"

      # ----- 4) Filtrado USA + 2-3 estrellas y formateo (ts robusto + fallback t√≠tulo) -----
      - name: Filter & format events
        run: |
          set -euo pipefail
          # 1) Reducimos filas a lo esencial (USA + 2/3 estrellas)
          jq -c '
            .[] |
            select(.attrs["data-country"]=="5" and (.attrs["data-importance"]=="2" or .attrs["data-importance"]=="3")) |
            {
              ts_raw: .attrs["data-event-datetime"],
              imp: .attrs["data-importance"],
              # intentar sacar t√≠tulo desde el <a> o texto del <td class="event">
              title: (
                ( [ .children[] | select(.tag=="td" and (.attrs.class//""|test("event"))) ][0] ) as $td |
                (
                  ( $td.children[]? | select(.tag=="a") | .attrs.title // .text ) // $td.text // ""
                )
              ) | gsub("\\s+";" ") | sub("^\\s+";"") | sub("\\s+$";"")
            }
          ' rows.json > events_raw0.json || echo "[]" > events_raw0.json

          # 2) Normalizamos timestamp: puede venir vac√≠o, en segundos o en milisegundos
          jq -c '
            [ .[] |
              .tsn = (
                if (.ts_raw|type=="number") then
                  ( if .ts_raw > 1000000000000 then ((.ts_raw/1000)|floor) else .ts_raw end )
                elif (.ts_raw|type=="string") then
                  # a veces viene ISO; intentamos parsearlo
                  ( .ts_raw | strptime("%Y-%m-%d %H:%M:%S")? // strptime("%Y-%m-%dT%H:%M:%S%z")? | mktime ) // null
                else null end
              )
              | select(.tsn != null and .title != "")
              | {
                  date: ( .tsn | strflocaltime("%Y-%m-%d") ),
                  time: ( .tsn | strflocaltime("%H:%M") ),
                  title: .title,
                  imp: (if .imp=="2" then "2‚≠êÔ∏è" else "3‚≠êÔ∏è" end)
                }
            ] | sort_by(.date,.time)
          ' events_raw0.json > events.json

          echo "Final events count: $(jq 'length' events.json)"
          jq '.[0:5]' events.json || true

      # ----- 5) Construcci√≥n y env√≠o del mensaje (sin cambios salvo conteo) -----
      - name: Build & Send (only if there are events)
        env:
          BOT_TOKEN: ${{ secrets.INVESTX_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
        run: |
          set -euo pipefail
          TZ_EUROPE=Europe/Madrid
          TODAY=$(TZ=$TZ_EUROPE date +%Y-%m-%d)
          WEEK_START=$(TZ=$TZ_EUROPE date -d "monday this week" +%Y-%m-%d)
          WEEK_END=$(TZ=$TZ_EUROPE date -d "sunday this week" +%Y-%m-%d)
          DOW=$(TZ=$TZ_EUROPE date +%u)   # 1..7

          if [ "$DOW" -ge 6 ]; then echo "Fin de semana: no se env√≠a."; exit 0; fi
          if [ ! -s events.json ] || [ "$(jq 'length' events.json)" -eq 0 ]; then
            echo "Sin eventos tras filtrado -> no se env√≠a."
            exit 0
          fi

          if [ "$DOW" -eq 1 ]; then
            SEL=$(jq --arg A "$WEEK_START" --arg B "$WEEK_END" -c '[ .[] | select(.date >= $A and .date <= $B) ]' events.json)
            HEADER=$(printf "üì£ Desde <b>InvestX</b> os informamos del <b>calendario econ√≥mico de EE.UU.</b> para esta semana.\n<i>Eventos relevantes (2‚≠êÔ∏è y 3‚≠êÔ∏è) ‚Äî Horario Europe/Madrid</i>")
          else
            SEL=$(jq --arg D "$TODAY" -c '[ .[] | select(.date == $D) ]' events.json)
            HEADER=$(printf "üì£ Desde <b>InvestX</b> os informamos del <b>calendario econ√≥mico de EE.UU.</b> ‚Äî Hoy %s.\n<i>Eventos relevantes (2‚≠êÔ∏è y 3‚≠êÔ∏è) ‚Äî Horario Europe/Madrid</i>" "$TODAY")
          fi

          echo "$SEL" > sel.json
          if [ "$(jq 'length' sel.json)" -eq 0 ]; then
            echo "No hay eventos en el rango pedido -> no se env√≠a."
            exit 0
          fi

          BODY=""
          mapfile -t DAYS < <(jq -r 'map(.date) | unique[]' sel.json)
          for DAY in "${DAYS[@]}"; do
            BODY="${BODY}$(printf "\n<b>‚Ä¢ %s</b>\n" "$DAY")"
            while IFS= read -r LINE; do
              LINE_ESC=$(printf "%s" "$LINE" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g' -e 's/"/\&quot;/g')
              HORA=$(printf "%s" "$LINE_ESC" | cut -d'|' -f1)
              TEXTO_EVENTO=$(printf "%s" "$LINE_ESC" | cut -d'|' -f2)
              BODY="${BODY}$(printf "‚Ä¢ <b>%s</b> ‚Äî %s\n" "$HORA" "$TEXTO_EVENTO")"
            done < <(jq -r --arg DAY "$DAY" '.[] | select(.date==$DAY) | "\(.time)|\(.title) (\(.imp))"' sel.json)
          done

          TEXTO="${HEADER}${BODY}"

          curl -sS "https://api.telegram.org/bot${BOT_TOKEN}/sendMessage" \
            -d chat_id="${CHAT_ID}" \
            -d parse_mode="HTML" \
            -d disable_web_page_preview=true \
            --data-urlencode text="$TEXTO"
