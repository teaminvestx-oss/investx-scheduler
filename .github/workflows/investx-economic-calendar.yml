name: InvestX Economic Calendar

on:
  schedule:
    - cron: "0 11 * * 1"   # Lunes 13:00 Madrid (11:00 UTC) ‚Äî resumen semanal
    - cron: "0 11 * * 2-5" # Mar‚ÄìVie 13:00 Madrid (11:00 UTC) ‚Äî resumen diario
  workflow_dispatch:

jobs:
  econ-calendar:
    runs-on: ubuntu-latest
    steps:
      - name: Install jq & pup
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl unzip
          curl -sL https://github.com/ericchiang/pup/releases/download/v0.4.0/pup_v0.4.0_linux_amd64.zip -o pup.zip
          unzip -o pup.zip
          sudo mv pup /usr/local/bin/

      - name: Fetch Investing page (with cookies)
        run: |
          UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36"
          CAL_URL="https://es.investing.com/economic-calendar/"
          curl -sSL "$CAL_URL" \
            -H "User-Agent: $UA" \
            -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \
            -c cookies.txt -b cookies.txt -o cal.html

      - name: Parse events from HTML (USD, 2-3 estrellas)
        run: |
          set -euo pipefail
          # Extrae filas del calendario
          pup 'tr[id^="eventRowId_"] json{}' < cal.html > rows.json || echo "[]" > rows.json

          # Filtra USA (data-country=5) e importancia 2/3
          jq -c '
            .[] |
            select(.attrs["data-country"]=="5" and (.attrs["data-importance"]=="2" or .attrs["data-importance"]=="3")) |
            {
              ts: ( .attrs["data-event-datetime"] | tonumber ),
              imp: ( .attrs["data-importance"] ),
              title: (
                [.children[] | select(.tag=="td" and (.attrs.class//""|test("event"))) ][0]
                | if has("children") then
                    (
                      .children[]? | select(.tag=="a") | .attrs.title // .text
                    ) // .text
                  else .text end
              ) | gsub("\\s+";" ") | sub("^\\s+";"") | sub("\\s+$";"")
            }
          ' rows.json > events_raw.json

          # Formato final con hora Europe/Madrid
          TZ=Europe/Madrid jq -c '
            map({
              date: (.ts | todate | strptime("%Y-%m-%dT%H:%M:%S%z") | strftime("%Y-%m-%d")),
              time: (.ts | todate | strptime("%Y-%m-%dT%H:%M:%S%z") | strftime("%H:%M")),
              title: .title,
              imp: (if .imp=="2" then "2‚≠êÔ∏è" else "3‚≠êÔ∏è" end)
            })
            | sort_by(.date,.time)
          ' events_raw.json > events.json

      - name: Build & Send message (no links, sin preview)
        env:
          BOT_TOKEN: ${{ secrets.INVESTX_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
        run: |
          set -euo pipefail

          # Fechas en horario Madrid
          TODAY=$(TZ=Europe/Madrid date +%Y-%m-%d)
          WEEK_START=$(TZ=Europe/Madrid date -d "monday this week" +%Y-%m-%d)
          WEEK_END=$(TZ=Europe/Madrid date -d "sunday this week" +%Y-%m-%d)

          # Lunes = semanal; Mar-Vie = diario
          DOW=$(TZ=Europe/Madrid date +%u)
          if [ "$DOW" -eq 1 ]; then
            jq --arg A "$WEEK_START" --arg B "$WEEK_END" -c '[ .[] | select(.date >= $A and .date <= $B) ]' events.json > sel.json
            INTRO="üì£ Desde <b>InvestX</b> os informamos del <b>calendario econ√≥mico de EE.UU.</b> para esta semana.\n<i>Eventos relevantes (2‚≠êÔ∏è y 3‚≠êÔ∏è) ‚Äî Horario Europe/Madrid</i>"
          else
            jq --arg D "$TODAY" -c '[ .[] | select(.date == $D) ]' events.json > sel.json
            FECHA=$(TZ=Europe/Madrid date +%Y-%m-%d)
            INTRO="üì£ Desde <b>InvestX</b> os informamos del <b>calendario econ√≥mico de EE.UU.</b> ‚Äî Hoy ${FECHA}.\n<i>Eventos relevantes (2‚≠êÔ∏è y 3‚≠êÔ∏è) ‚Äî Horario Europe/Madrid</i>"
          fi

          COUNT=$(jq 'length' sel.json)
          if [ "$COUNT" -eq 0 ]; then
            echo "Sin eventos -> no enviamos mensaje."
            exit 0
          fi

          # Construir cuerpo (agrupado por fecha)
          BODY=""
          for DAY in $(jq -r 'map(.date) | unique[]' sel.json); do
            BODY="${BODY}\n<b>‚Ä¢ ${DAY}</b>\n"
            jq --arg DAY "$DAY" -r '.[] | select(.date==$DAY) | "‚Ä¢ <b>\(.time)</b> ‚Äî \(.title) (\(.imp))"' sel.json >> lines.txt
            sed -e 's/&/&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g' -e 's/"/\&quot;/g' lines.txt > lines_esc.txt
            while IFS= read -r L; do BODY="${BODY}\n${L}"; done < lines_esc.txt
            rm -f lines.txt lines_esc.txt
          done

          # Unir mensaje final con saltos de l√≠nea reales (no %0A)
          TEXTO="${INTRO}${BODY}"

          # Evitar tarjetas de vista previa y mandar tal cual
          curl -sS "https://api.telegram.org/bot${BOT_TOKEN}/sendMessage" \
            -d chat_id="${CHAT_ID}" \
            -d parse_mode="HTML" \
            -d disable_web_page_preview=true \
            --data-urlencode text="$TEXTO"
