name: InvestX Economic Calendar

on:
  schedule:
    - cron: "0 11 * * 1"   # Lunes 13:00 Madrid (11:00 UTC) ‚Äî semanal
    - cron: "0 11 * * 2-5" # Mar‚ÄìVie 13:00 Madrid (11:00 UTC) ‚Äî diario
  workflow_dispatch:

jobs:
  econ-calendar:
    runs-on: ubuntu-latest
    steps:
      # ----- deps -----
      - name: Install jq & pup
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y jq curl unzip
          curl -sL https://github.com/ericchiang/pup/releases/download/v0.4.0/pup_v0.4.0_linux_amd64.zip -o pup.zip
          unzip -o pup.zip
          sudo mv pup /usr/local/bin/

      # ----- 1) Obtener cookies + HTML base -----
      - name: Seed cookies & base HTML
        run: |
          set -e
          UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36"
          for URL in "https://es.investing.com/economic-calendar/" "https://www.investing.com/economic-calendar/"; do
            curl -sSL "$URL" \
              -H "User-Agent: $UA" \
              -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \
              -c cookies.txt -b cookies.txt -o /dev/null || true
          done

          # ----- 2) AJAX endpoint (actualizado: arrays + campos obligatorios) -----
      - name: Try AJAX endpoint (preferred)
        run: |
          set -euo pipefail
          UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36"
          FROM=$(TZ=Europe/Madrid date -d "monday this week" +%Y-%m-%d)
          TO=$(TZ=Europe/Madrid date -d "sunday this week" +%Y-%m-%d)

          # NOTA: country[]=5  (USA), importance[]=2,3 ; timeZone=55 ~ Madrid (CEST/CET en Investing)
          curl -sSL 'https://www.investing.com/economic-calendar/Service/getCalendarFilteredData' \
            -H "User-Agent: $UA" \
            -H 'Accept: application/json, text/javascript, */*; q=0.01' \
            -H 'Content-Type: application/x-www-form-urlencoded; charset=UTF-8' \
            -H 'X-Requested-With: XMLHttpRequest' \
            -H 'Origin: https://www.investing.com' \
            -H 'Referer: https://www.investing.com/economic-calendar/' \
            -b cookies.txt -c cookies.txt \
            --data "country[]=5&importance[]=2&importance[]=3&timeZone=55&timeFilter=time_only&currentTab=custom&limit_from=0&dateFrom=${FROM}&dateTo=${TO}&action=filter" \
            -o ajax.json || echo '{}' > ajax.json

          # La API devuelve {"data":"<tr>...</tr>"} o HTML directo
          if jq -e '.data' ajax.json >/dev/null 2>&1; then
            jq -r '.data' ajax.json > ajax_data.html
          else
            # Puede venir HTML plano
            cp ajax.json ajax_data.html || true
          fi

          # Extraer filas <tr id="eventRowId_...">
          if [ -s ajax_data.html ]; then
            pup 'tr[id^="eventRowId_"] json{}' < ajax_data.html > rows.json || echo "[]" > rows.json
          else
            echo "[]" > rows.json
          fi
          echo "AJAX rows count: $(jq 'length' rows.json)"

      # ----- 3) Fallback: HTML completo (ES/EN) si no hubo filas -----
      - name: Fallback to full HTML
        if: ${{ always() }}
        run: |
          set -euo pipefail
          COUNT=$(jq 'length' rows.json || echo 0)
          if [ "$COUNT" -gt 0 ]; then
            echo "Saltamos fallback: ya hay filas desde AJAX."
            exit 0
          fi

          UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36"
          for SRC in "https://es.investing.com/economic-calendar/" "https://www.investing.com/economic-calendar/"; do
            curl -sSL "$SRC" -H "User-Agent: $UA" -b cookies.txt -c cookies.txt -o cal.html || true
            pup 'tr[id^="eventRowId_"] json{}' < cal.html > rows_try.json || echo "[]" > rows_try.json
            if [ -s rows_try.json ] && [ "$(jq 'length' rows_try.json)" -gt 0 ]; then
              mv rows_try.json rows.json
              break
            fi
          done
          if [ ! -s rows.json ]; then echo "[]" > rows.json; fi
          echo "Fallback rows count: $(jq 'length' rows.json)"

             # ----- 4) Filtrar y formatear usando epoch en <td class="time" data-value> -----
      - name: Filter & format events
        run: |
          set -euo pipefail

          # rows.json viene del paso de fallback (45 filas). Si no existe, intenta regenerarlo.
          if [ ! -s rows.json ]; then
            echo "rows.json no existe o est√° vac√≠o; intento re-extraer desde cal.html..." >&2
            if [ -s cal.html ]; then
              pup 'tr[id^="eventRowId_"] json{}' < cal.html > rows.json || echo "[]" > rows.json
            else
              echo "[]" > rows.json
            fi
          fi

          # Parseo robusto:
          # - epoch desde td.time[data-value] o su <span> hijo
          # - importancia desde atributo o contando <i> en 'sentiment'
          # - t√≠tulo desde celda 'event'
          TZ=Europe/Madrid jq -c '
            [ .[] |
              {
                country: .attrs["data-country"],
                imp_attr: .attrs["data-importance"],
                sent_cnt: (([ .children[]? | select(.tag=="td" and (.attrs.class//""|test("sentiment"))) ][0]?.children // []
                           | map(select(.tag=="i")) | length) // 0),
                time_td:  ( [ .children[]? | select(.tag=="td" and (.attrs.class//""|test("time"))) ][0] ),
                event_td: ( [ .children[]? | select(.tag=="td" and (.attrs.class//""|test("event"))) ][0] )
              }
              |
              .epoch_raw = (
                .time_td.attrs["data-value"] //
                ( [ .time_td.children[]? | select(.attrs?["data-value"]) ][0]?.attrs["data-value"] ) //
                null
              )
              |
              .epoch = (
                if (.epoch_raw|type)=="string" then (.epoch_raw|tonumber?) else .epoch_raw end
              )
              |
              .epoch = (
                if .epoch==null then null
                elif .epoch > 1000000000000 then ((.epoch/1000)|floor)  # ms -> s
                else .epoch end
              )
              |
              .title = (
                (.event_td // {}) as $td
                | ( ($td.children[]? | select(.tag=="a") | .attrs.title // .text) // $td.text // "" )
                | gsub("\\s+";" ") | sub("^\\s+";"") | sub("\\s+$";"")
              )
              |
              .impn = ((.imp_attr|tonumber?) // .sent_cnt)
              |
              select(.epoch != null and .title != "")
              |
              {
                date: (.epoch | strflocaltime("%Y-%m-%d")),
                time: (.epoch | strflocaltime("%H:%M")),
                title: .title,
                country: .country,
                impn: .impn
              }
            ]
            # USA (5) + importancia 2 o 3
            | [ .[] | select(.country=="5" and (.impn==2 or .impn==3))
                | {date, time, title, imp: (if .impn==2 then "2‚≠êÔ∏è" else "3‚≠êÔ∏è" end)}
              ]
            | sort_by(.date,.time)
          ' rows.json > events.json || echo "[]" > events.json

          echo "Final events count: $(jq 'length' events.json)"
          echo "Sample:"
          jq '.[0:8]' events.json || true

      # ----- 5) Construcci√≥n y env√≠o del mensaje (sin cambios salvo conteo) -----
      - name: Build & Send (only if there are events)
        env:
          BOT_TOKEN: ${{ secrets.INVESTX_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
        run: |
          set -euo pipefail
          TZ_EUROPE=Europe/Madrid
          TODAY=$(TZ=$TZ_EUROPE date +%Y-%m-%d)
          WEEK_START=$(TZ=$TZ_EUROPE date -d "monday this week" +%Y-%m-%d)
          WEEK_END=$(TZ=$TZ_EUROPE date -d "sunday this week" +%Y-%m-%d)
          DOW=$(TZ=$TZ_EUROPE date +%u)   # 1..7

          if [ "$DOW" -ge 6 ]; then echo "Fin de semana: no se env√≠a."; exit 0; fi
          if [ ! -s events.json ] || [ "$(jq 'length' events.json)" -eq 0 ]; then
            echo "Sin eventos tras filtrado -> no se env√≠a."
            exit 0
          fi

          if [ "$DOW" -eq 1 ]; then
            SEL=$(jq --arg A "$WEEK_START" --arg B "$WEEK_END" -c '[ .[] | select(.date >= $A and .date <= $B) ]' events.json)
            HEADER=$(printf "üì£ Desde <b>InvestX</b> os informamos del <b>calendario econ√≥mico de EE.UU.</b> para esta semana.\n<i>Eventos relevantes (2‚≠êÔ∏è y 3‚≠êÔ∏è) ‚Äî Horario Europe/Madrid</i>")
          else
            SEL=$(jq --arg D "$TODAY" -c '[ .[] | select(.date == $D) ]' events.json)
            HEADER=$(printf "üì£ Desde <b>InvestX</b> os informamos del <b>calendario econ√≥mico de EE.UU.</b> ‚Äî Hoy %s.\n<i>Eventos relevantes (2‚≠êÔ∏è y 3‚≠êÔ∏è) ‚Äî Horario Europe/Madrid</i>" "$TODAY")
          fi

          echo "$SEL" > sel.json
          if [ "$(jq 'length' sel.json)" -eq 0 ]; then
            echo "No hay eventos en el rango pedido -> no se env√≠a."
            exit 0
          fi

          BODY=""
          mapfile -t DAYS < <(jq -r 'map(.date) | unique[]' sel.json)
          for DAY in "${DAYS[@]}"; do
            BODY="${BODY}$(printf "\n<b>‚Ä¢ %s</b>\n" "$DAY")"
            while IFS= read -r LINE; do
              LINE_ESC=$(printf "%s" "$LINE" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g' -e 's/"/\&quot;/g')
              HORA=$(printf "%s" "$LINE_ESC" | cut -d'|' -f1)
              TEXTO_EVENTO=$(printf "%s" "$LINE_ESC" | cut -d'|' -f2)
              BODY="${BODY}$(printf "‚Ä¢ <b>%s</b> ‚Äî %s\n" "$HORA" "$TEXTO_EVENTO")"
            done < <(jq -r --arg DAY "$DAY" '.[] | select(.date==$DAY) | "\(.time)|\(.title) (\(.imp))"' sel.json)
          done

          TEXTO="${HEADER}${BODY}"

          curl -sS "https://api.telegram.org/bot${BOT_TOKEN}/sendMessage" \
            -d chat_id="${CHAT_ID}" \
            -d parse_mode="HTML" \
            -d disable_web_page_preview=true \
            --data-urlencode text="$TEXTO"
