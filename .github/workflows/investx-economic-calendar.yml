name: InvestX Economic Calendar

on:
  schedule:
    - cron: "0 11 * * 1"   # Lunes 13:00 Madrid (11:00 UTC) ‚Äî resumen semanal
    - cron: "0 11 * * 2-5" # Mar‚ÄìVie 13:00 Madrid (11:00 UTC) ‚Äî resumen diario
  workflow_dispatch:

jobs:
  econ-calendar:
    runs-on: ubuntu-latest
    steps:
      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y jq pup

      # 1) Cargamos la p√°gina de Investing (ES) y guardamos cookies para evitar bloqueos
      - name: Fetch Investing page (with cookies)
        run: |
          UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36"
          CAL_URL="https://es.investing.com/economic-calendar/"
          curl -sSL "$CAL_URL" \
            -H "User-Agent: $UA" \
            -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \
            -c cookies.txt -b cookies.txt -o cal.html
          # Descargar tambi√©n la versi√≥n en ingl√©s por si ES cambia estructura
          curl -sSL "https://www.investing.com/economic-calendar/" \
            -H "User-Agent: $UA" \
            -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \
            -c cookies.txt -b cookies.txt -o cal_en.html

      # 2) Extraemos filas del calendario desde el HTML (no JSON)
      #    y filtramos: data-country="5" (USA) y data-importance 2 o 3
      - name: Parse events from HTML
        run: |
          set -euo pipefail
          # Usamos la p√°gina ES si contiene filas; si no, probamos EN
          for SRC in cal.html cal_en.html; do
            pup 'tr[id^="eventRowId_"] json{}' < "$SRC" > rows.json || true
            if [ -s rows.json ]; then break; fi
          done

          # rows.json -> events.json con solo USA (5) e importancia 2/3
          jq -c '
            .[] |
            select(.attrs["data-country"]=="5" and (.attrs["data-importance"]=="2" or .attrs["data-importance"]=="3")) |
            {
              ts: ( .attrs["data-event-datetime"] | tonumber ),
              imp: ( .attrs["data-importance"] ),
              # hora visible en la tabla
              time_txt: (
                [.children[] | select(.tag=="td" and (.attrs.class//""|test("time"))) ][0].text // ""
              ),
              # t√≠tulo del evento (preferimos atributo title del <a>)
              title: (
                [.children[] | select(.tag=="td" and (.attrs.class//""|test("event"))) ][0]
                | if has("children") then
                    (
                      .children[]? | select(.tag=="a") | .attrs.title // .text
                    ) // .text
                  else .text end
              ) | gsub("\\s+";" ") | sub("^\\s+";"") | sub("\\s+$";"")
            }
          ' rows.json > events_raw.json

          # Convertimos a estructura final con fecha local Europe/Madrid
          # y ordenamos por timestamp
          TZ=Europe/Madrid jq -c '
            map({
              date: (.ts | todate | strptime("%Y-%m-%dT%H:%M:%S%z") | strftime("%Y-%m-%d")),
              time: (.ts | todate | strptime("%Y-%m-%dT%H:%M:%S%z") | strftime("%H:%M")),
              title: .title,
              imp: (if .imp=="2" then "2‚≠êÔ∏è" else "3‚≠êÔ∏è" end)
            })
            | sort_by(.date,.time)
          ' events_raw.json > events.json

      # 3) Construimos y enviamos el mensaje a Telegram
      - name: Build & Send message
        env:
          BOT_TOKEN: ${{ secrets.INVESTX_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
        run: |
          set -euo pipefail
          DOW=$(date -u +%u)                     # 1..7
          TODAY=$(TZ=Europe/Madrid date +%Y-%m-%d)
          WEEK_START=$(TZ=Europe/Madrid date -d "monday this week" +%Y-%m-%d)
          WEEK_END=$(TZ=Europe/Madrid date -d "sunday this week" +%Y-%m-%d)

          if [ "$DOW" -eq 1 ]; then
            # Lunes: resumen semanal
            HEADER="üì£ <b>Desde InvestX os informamos del calendario econ√≥mico de EE.UU. ‚Äî Resumen semanal</b>%0A<i>Eventos relevantes (2‚≠êÔ∏è y 3‚≠êÔ∏è) ‚Äî Horario Europe/Madrid</i>%0A"
            jq --arg A "$WEEK_START" --arg B "$WEEK_END" -c \
              '[ .[] | select(.date >= $A and .date <= $B) ]' events.json > sel.json
          else
            # Mar‚ÄìVie: diario
            DIA_FMT=$(TZ=Europe/Madrid date +'%A %d %b')
            HEADER="üì£ <b>Desde InvestX os informamos del calendario econ√≥mico de EE.UU. ‚Äî Hoy (${DIA_FMT})</b>%0A<i>Eventos relevantes (2‚≠êÔ∏è y 3‚≠êÔ∏è) ‚Äî Horario Europe/Madrid</i>%0A"
            jq --arg D "$TODAY" -c \
              '[ .[] | select(.date == $D) ]' events.json > sel.json
          fi

          COUNT=$(jq 'length' sel.json)
          if [ "$COUNT" -eq 0 ]; then
            echo "No hay eventos que cumplan el filtro. No se env√≠a mensaje."
            exit 0
          fi

          # Agrupamos por d√≠a y formateamos como lista
          BODY=""
          for DAY in $(jq -r 'map(.date) | unique[]' sel.json); do
            DIA_FMT=$(TZ=Europe/Madrid date -d "$DAY" +'%A %d %b')
            BODY="${BODY}%0A<b>‚Ä¢ ${DIA_FMT}</b>%0A"
            jq --arg DAY "$DAY" -r '
              .[] | select(.date==$DAY) |
              "‚Ä¢ <b>\(.time)</b> ‚Äî \(.title) (\(.imp))"
            ' sel.json | sed 's/$/%0A/' | tr -d '\n' >> body.txt
            BODY="${BODY}$(cat body.txt)"; rm -f body.txt
          done

          TEXTO="${HEADER}${BODY}%0A%0Aüîó <a href=\"https://es.investing.com/economic-calendar/\">Ver calendario completo</a>"

          curl -sS "https://api.telegram.org/bot${BOT_TOKEN}/sendMessage" \
            -d chat_id="${CHAT_ID}" \
            -d parse_mode="HTML" \
            --data-urlencode text="${TEXTO}"
