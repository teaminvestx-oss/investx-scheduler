name: InvestX Economic Calendar

on:
  schedule:
    - cron: "0 11 * * 1"   # Lunes 13:00 Madrid (11:00 UTC) ‚Äî semanal
    - cron: "0 11 * * 2-5" # Mar‚ÄìVie 13:00 Madrid (11:00 UTC) ‚Äî diario
  workflow_dispatch:

jobs:
  econ-calendar:
    runs-on: ubuntu-latest
    steps:
      # ----- deps -----
      - name: Install jq & pup
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y jq curl unzip
          curl -sL https://github.com/ericchiang/pup/releases/download/v0.4.0/pup_v0.4.0_linux_amd64.zip -o pup.zip
          unzip -o pup.zip
          sudo mv pup /usr/local/bin/

      # ----- 1) Obtener cookies + HTML base -----
      - name: Seed cookies & base HTML
        run: |
          set -e
          UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36"
          for URL in "https://es.investing.com/economic-calendar/" "https://www.investing.com/economic-calendar/"; do
            curl -sSL "$URL" \
              -H "User-Agent: $UA" \
              -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \
              -c cookies.txt -b cookies.txt -o /dev/null || true
          done

          # ----- 2) AJAX endpoint (actualizado: arrays + campos obligatorios) -----
      - name: Try AJAX endpoint (preferred)
        run: |
          set -euo pipefail
          UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36"
          FROM=$(TZ=Europe/Madrid date -d "monday this week" +%Y-%m-%d)
          TO=$(TZ=Europe/Madrid date -d "sunday this week" +%Y-%m-%d)

          # NOTA: country[]=5  (USA), importance[]=2,3 ; timeZone=55 ~ Madrid (CEST/CET en Investing)
          curl -sSL 'https://www.investing.com/economic-calendar/Service/getCalendarFilteredData' \
            -H "User-Agent: $UA" \
            -H 'Accept: application/json, text/javascript, */*; q=0.01' \
            -H 'Content-Type: application/x-www-form-urlencoded; charset=UTF-8' \
            -H 'X-Requested-With: XMLHttpRequest' \
            -H 'Origin: https://www.investing.com' \
            -H 'Referer: https://www.investing.com/economic-calendar/' \
            -b cookies.txt -c cookies.txt \
            --data "country[]=5&importance[]=2&importance[]=3&timeZone=55&timeFilter=time_only&currentTab=custom&limit_from=0&dateFrom=${FROM}&dateTo=${TO}&action=filter" \
            -o ajax.json || echo '{}' > ajax.json

          # La API devuelve {"data":"<tr>...</tr>"} o HTML directo
          if jq -e '.data' ajax.json >/dev/null 2>&1; then
            jq -r '.data' ajax.json > ajax_data.html
          else
            # Puede venir HTML plano
            cp ajax.json ajax_data.html || true
          fi

          # Extraer filas <tr id="eventRowId_...">
          if [ -s ajax_data.html ]; then
            pup 'tr[id^="eventRowId_"] json{}' < ajax_data.html > rows.json || echo "[]" > rows.json
          else
            echo "[]" > rows.json
          fi
          echo "AJAX rows count: $(jq 'length' rows.json)"

      # ----- 3) Fallback: HTML completo (ES/EN) si no hubo filas -----
      - name: Fallback to full HTML
        if: ${{ always() }}
        run: |
          set -euo pipefail
          COUNT=$(jq 'length' rows.json || echo 0)
          if [ "$COUNT" -gt 0 ]; then
            echo "Saltamos fallback: ya hay filas desde AJAX."
            exit 0
          fi

          UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36"
          for SRC in "https://es.investing.com/economic-calendar/" "https://www.investing.com/economic-calendar/"; do
            curl -sSL "$SRC" -H "User-Agent: $UA" -b cookies.txt -c cookies.txt -o cal.html || true
            pup 'tr[id^="eventRowId_"] json{}' < cal.html > rows_try.json || echo "[]" > rows_try.json
            if [ -s rows_try.json ] && [ "$(jq 'length' rows_try.json)" -gt 0 ]; then
              mv rows_try.json rows.json
              break
            fi
          done
          if [ ! -s rows.json ]; then echo "[]" > rows.json; fi
          echo "Fallback rows count: $(jq 'length' rows.json)"

         # ----- 4) Filtrado USA + 2-3 estrellas y formateo (robusto contra nulls) -----
      - name: Filter & format events
        run: |
          set -euo pipefail

          # Debe existir el HTML del fallback
          if [ ! -s cal.html ]; then
            echo "Falta cal.html (fallback). No se puede parsear." >&2
            echo "[]" > events.json
            exit 0
          fi

          # Extrae TODOS los <tr> (separadores de d√≠a + filas de evento)
          pup 'tr json{}' < cal.html > tr_all.json || echo "null" > tr_all.json
          if ! jq -e . tr_all.json >/dev/null 2>&1; then
            echo "null" > tr_all.json
          fi

          jq -c '
            # ---------- utilidades ----------
            def month_es_to_num:
              {
                "enero":"01","febrero":"02","marzo":"03","abril":"04","mayo":"05","junio":"06",
                "julio":"07","agosto":"08","septiembre":"09","setiembre":"09","octubre":"10",
                "noviembre":"11","diciembre":"12"
              };
            def textify: ( . // "" ) | gsub("\\s+";" ") | sub("^\\s+";"") | sub("\\s+$";"");
            def parse_es_date($s):
              # "Martes, 16 de septiembre de 2025" -> "2025-09-16"
              ( try ($s | capture("(?<d>\\d{1,2})\\s+de\\s+(?<m>[[:alpha:]]+)\\s+de\\s+(?<y>\\d{4})")) catch null ) as $c
              | if $c==null then null
                else ($c.y + "-" + (month_es_to_num[$c.m]) + "-" +
                      ( ($c.d|tonumber|tostring) | if (.|length)==1 then "0"+. else . end ))
                end;
            def is_dayrow: ((.attrs?.class // "") | test("theDay|newDay|dayHeader|theDayRow"));

            # ---------- entrada segura ----------
            ( . // [] ) as $nodes

            # ---------- mapeo a items ----------
            | [ $nodes[]
                | if is_dayrow then
                    { kind:"day",
                      date_txt: ([ .children[]? | select(.tag=="td") ][0]?.text | textify) }
                  else
                    { kind:"row",
                      country_attr: .attrs?["data-country"],
                      time_txt: ( [ .children[]? | select(.tag=="td" and (.attrs.class//""|test("time"))) ][0]?.text | textify ),
                      stars: (
                        ( [ .children[]? | select(.tag=="td" and (.attrs.class//""|test("sentiment"))) ][0]?.children // []
                          | map(select(.tag=="i")) | length ) // 0
                      ),
                      title: (
                        ( [ .children[]? | select(.tag=="td" and (.attrs.class//""|test("event"))) ][0]? ) as $td
                        | ( ($td.children[]? | select(.tag=="a") | .attrs.title // .text) // $td.text // "" ) | textify
                      ),
                      flag_cell: ( [ .children[]? | select(.tag=="td" and (.attrs.class//""|test("flagCur"))) ][0]? | tostring )
                    }
                  end
              ] as $items

            # ---------- propagar fecha ----------
            | (reduce $items[] as $it (
                {current_date:null, out: []};
                if $it.kind=="day" then
                  .current_date = (parse_es_date($it.date_txt))
                elif $it.kind=="row" then
                  .out += [ $it + {date: .current_date} ]
                else .
                end
              )).out

            # ---------- filtrar y formatear ----------
            | [ .[]
                | select(.date != null and (.time_txt // "") != "" and (.title // "") != "")
                | .imp = (if .stars>=3 then "3‚≠êÔ∏è" elif .stars==2 then "2‚≠êÔ∏è" else null end)
                | select(.imp != null)
                | select(
                    (.country_attr=="5") or
                    (((.flag_cell // "")) | test("USD|United States|Estados Unidos|EE\\.UU\\.", "i"))
                  )
                | ( (.time_txt | capture("(?<hh>\\d{1,2})\\s*:\\s*(?<mm>\\d{2})") ) as $c
                    | .hour = ( ($c.hh|tonumber|tostring) | if (.|length)==1 then "0"+. else . end )
                    | { date: .date, time: (.hour + ":" + $c.mm), title: .title, imp: .imp }
                  )
              ]
              | sort_by(.date,.time)
          ' tr_all.json > events.json || echo "[]" > events.json

          echo "Final events count: $(jq 'length' events.json)"
          jq '.[0:8]' events.json || true


      # ----- 5) Construcci√≥n y env√≠o del mensaje (sin cambios salvo conteo) -----
      - name: Build & Send (only if there are events)
        env:
          BOT_TOKEN: ${{ secrets.INVESTX_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
        run: |
          set -euo pipefail
          TZ_EUROPE=Europe/Madrid
          TODAY=$(TZ=$TZ_EUROPE date +%Y-%m-%d)
          WEEK_START=$(TZ=$TZ_EUROPE date -d "monday this week" +%Y-%m-%d)
          WEEK_END=$(TZ=$TZ_EUROPE date -d "sunday this week" +%Y-%m-%d)
          DOW=$(TZ=$TZ_EUROPE date +%u)   # 1..7

          if [ "$DOW" -ge 6 ]; then echo "Fin de semana: no se env√≠a."; exit 0; fi
          if [ ! -s events.json ] || [ "$(jq 'length' events.json)" -eq 0 ]; then
            echo "Sin eventos tras filtrado -> no se env√≠a."
            exit 0
          fi

          if [ "$DOW" -eq 1 ]; then
            SEL=$(jq --arg A "$WEEK_START" --arg B "$WEEK_END" -c '[ .[] | select(.date >= $A and .date <= $B) ]' events.json)
            HEADER=$(printf "üì£ Desde <b>InvestX</b> os informamos del <b>calendario econ√≥mico de EE.UU.</b> para esta semana.\n<i>Eventos relevantes (2‚≠êÔ∏è y 3‚≠êÔ∏è) ‚Äî Horario Europe/Madrid</i>")
          else
            SEL=$(jq --arg D "$TODAY" -c '[ .[] | select(.date == $D) ]' events.json)
            HEADER=$(printf "üì£ Desde <b>InvestX</b> os informamos del <b>calendario econ√≥mico de EE.UU.</b> ‚Äî Hoy %s.\n<i>Eventos relevantes (2‚≠êÔ∏è y 3‚≠êÔ∏è) ‚Äî Horario Europe/Madrid</i>" "$TODAY")
          fi

          echo "$SEL" > sel.json
          if [ "$(jq 'length' sel.json)" -eq 0 ]; then
            echo "No hay eventos en el rango pedido -> no se env√≠a."
            exit 0
          fi

          BODY=""
          mapfile -t DAYS < <(jq -r 'map(.date) | unique[]' sel.json)
          for DAY in "${DAYS[@]}"; do
            BODY="${BODY}$(printf "\n<b>‚Ä¢ %s</b>\n" "$DAY")"
            while IFS= read -r LINE; do
              LINE_ESC=$(printf "%s" "$LINE" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g' -e 's/"/\&quot;/g')
              HORA=$(printf "%s" "$LINE_ESC" | cut -d'|' -f1)
              TEXTO_EVENTO=$(printf "%s" "$LINE_ESC" | cut -d'|' -f2)
              BODY="${BODY}$(printf "‚Ä¢ <b>%s</b> ‚Äî %s\n" "$HORA" "$TEXTO_EVENTO")"
            done < <(jq -r --arg DAY "$DAY" '.[] | select(.date==$DAY) | "\(.time)|\(.title) (\(.imp))"' sel.json)
          done

          TEXTO="${HEADER}${BODY}"

          curl -sS "https://api.telegram.org/bot${BOT_TOKEN}/sendMessage" \
            -d chat_id="${CHAT_ID}" \
            -d parse_mode="HTML" \
            -d disable_web_page_preview=true \
            --data-urlencode text="$TEXTO"
