name: InvestX Economic Calendar

on:
  schedule:
    - cron: "0 11 * * 1-5"   # L-V 13:00 Madrid (11:00 UTC)
  workflow_dispatch:

jobs:
  econ-calendar:
    runs-on: ubuntu-latest
    steps:
      - name: Set up job
        run: echo "‚ñ∂Ô∏è Iniciando flujo Econ Calendar"

      - name: Install jq & pup (para otros usos / compat)
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl unzip
          curl -sL https://github.com/ericchiang/pup/releases/download/v0.4.0/pup_v0.4.0_linux_amd64.zip -o pup.zip
          unzip -o pup.zip
          sudo mv pup /usr/local/bin/

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name: Install Puppeteer
        run: npm install puppeteer

            - name: Build grab script (filtra DOM: USA + 2/3‚≠ê y captura ajustada)
        run: |
          cat > grab.js <<'EOF'
          const puppeteer = require('puppeteer');
          const sleep = (ms) => new Promise(r => setTimeout(r, ms));

          (async () => {
            const browser = await puppeteer.launch({
              headless: 'new',
              args: ['--no-sandbox','--disable-setuid-sandbox','--lang=es-ES,es']
            });
            const page = await browser.newPage();
            await page.setUserAgent('Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124 Safari/537.36');
            await page.setViewport({ width: 1440, height: 2400, deviceScaleFactor: 2 });

            await page.goto('https://es.investing.com/economic-calendar/', { waitUntil: 'domcontentloaded', timeout: 60000 });

            // Aceptar cookies si aparece
            await page.evaluate(() => {
              const btn = [...document.querySelectorAll("button,a")].find(b =>
                /aceptar|accept|consent/i.test((b.innerText||'').toLowerCase())
              ); btn?.click();
            });
            await sleep(800);

            // Intentar ‚ÄúEsta semana‚Äù (si existe)
            await page.evaluate(() => {
              const el = [...document.querySelectorAll('a,button')].find(a =>
                /esta semana|this week/i.test((a.innerText||'').toLowerCase())
              ); el?.click();
            });
            await sleep(800);

            // Esperar filas del calendario
            await page.waitForSelector('tr[id^="eventRowId_"], tr.theDay, tr.newDay', { timeout: 20000 }).catch(()=>{});

            // === FILTRO DURO SOBRE EL DOM: USA + 2/3 ‚≠ê ===
            await page.evaluate(() => {
              const keepCountry = '5';                         // USA
              const keepImp = new Set(['2','3']);              // 2 y 3 estrellas

              // 1) Ocultar eventos que NO cumplan (por attrs o por an√°lisis de celdas)
              for (const tr of document.querySelectorAll('tr[id^="eventRowId_"], tr.js-event-item')) {
                const cAttr = tr.getAttribute('data-country') || tr.dataset?.country || '';
                const iAttr = tr.getAttribute('data-importance') || tr.dataset?.importance || '';

                // Si no hay attrs, inferir:
                let inferredCountryOK = false;
                let inferredImpOK = false;

                // Pa√≠s por bandera/c√≥digo
                const flagCell = tr.querySelector('td.flagCur');
                const flagTxt = (flagCell?.innerText || '').toUpperCase();
                const flagSpan = flagCell?.querySelector('span[class*="USA"]');
                if (cAttr === '5' || flagTxt.includes('USD') || flagSpan) inferredCountryOK = true;

                // Importancia por estrellas en <td class="sentiment"> (cuenta <i>)
                const senti = tr.querySelector('td.sentiment');
                const stars = senti ? senti.querySelectorAll('i').length : 0;
                if (keepImp.has(iAttr) || stars >= 2) inferredImpOK = true;

                const ok = ( (cAttr === keepCountry) || inferredCountryOK ) &&
                           ( keepImp.has(iAttr) || inferredImpOK );

                if (!ok) tr.style.display = 'none';
              }

              // 2) Ocultar separadores de d√≠a sin eventos visibles debajo
              const dayRows = Array.from(document.querySelectorAll('tr.theDay, tr.newDay, tr.dayHeader'));
              const isVisibleEvent = (r) => r.matches('tr[id^="eventRowId_"], tr.js-event-item') && r.style.display !== 'none';

              for (const dr of dayRows) {
                let hasAny = false;
                for (let sib = dr.nextElementSibling; sib; sib = sib.nextElementSibling) {
                  if (sib.matches('tr.theDay, tr.newDay, tr.dayHeader')) break; // siguiente d√≠a
                  if (isVisibleEvent(sib)) { hasAny = true; break; }
                }
                if (!hasAny) dr.style.display = 'none';
              }

              // 3) Quitar anuncios/barras flotantes que estorben
              for (const sel of [
                '#topBarAndAds', '.midHeader', '#banner', '.stickyFooter', '.js-consent-banner',
                'iframe', '.adsbygoogle', '.advertisement'
              ]) document.querySelectorAll(sel).forEach(e => e.remove());
            });

            // Captura AJUSTADA del bloque de tabla; si no existe, full page
            const table = await page.$('#economicCalendarData') || await page.$('table.genTbl');
            await page.evaluate(() => window.scrollTo(0, 0));
            await sleep(300);

            if (table) {
              await table.screenshot({ path: 'calendar.png' });
            } else {
              await page.screenshot({ path: 'calendar.png', fullPage: true });
            }

            console.log('‚úÖ Captura filtrada generada: calendar.png');
            await browser.close();
          })().catch(err => { console.error(err); process.exit(1); });
          EOF


            // 5) Esperar y capturar la tabla (ajustada); si no existe, full page
            await page.waitForSelector('#economicCalendarData, table.genTbl', { timeout: 20000 }).catch(()=>{});
            const table = await page.$('#economicCalendarData') || await page.$('table.genTbl');

            await page.evaluate(() => window.scrollTo(0, 0));
            await sleep(300);

            if (table) {
              await table.screenshot({ path: 'calendar.png' });
            } else {
              await page.screenshot({ path: 'calendar.png', fullPage: true });
            }

            console.log('‚úÖ Captura generada: calendar.png');
            await browser.close();
          })().catch(err => { console.error(err); process.exit(1); });
          EOF

      - name: Run grabber
        run: node grab.js

      - name: Check screenshot exists
        run: |
          ls -lh
          test -s calendar.png

      - name: Install Pillow (Python imaging)
        run: pip3 install pillow requests

      - name: Send to Telegram (Python, con conversi√≥n y fallback)
        env:
          BOT_TOKEN: ${{ secrets.INVESTX_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
        run: |
          python3 - <<'PY'
          import os, io, sys, requests
          from PIL import Image

          bot = os.environ['BOT_TOKEN']
          chat = os.environ['CHAT_ID']

          # 1) Abrir PNG y convertir a JPEG (RGB) limitando lado largo
          src = "calendar.png"
          if not os.path.exists(src) or os.path.getsize(src)==0:
            print("calendar.png no existe o est√° vac√≠o", file=sys.stderr); sys.exit(1)

          im = Image.open(src).convert("RGB")
          w, h = im.size
          MAX_SIDE = 4096  # seguro para Telegram
          scale = min(1.0, MAX_SIDE / max(w, h))
          if scale < 1.0:
            im = im.resize((int(w*scale), int(h*scale)), Image.LANCZOS)

          buf = io.BytesIO()
          im.save(buf, format="JPEG", quality=85, optimize=True, progressive=True)
          buf.seek(0)

          caption = "üóìÔ∏è Calendario Econ√≥mico (USA, ‚≠ê‚≠ê y ‚≠ê‚≠ê‚≠ê) ‚Äî Semana actual ¬∑ TZ Europe/Madrid ¬∑ Fuente: Investing"

          def send_photo():
            url = f"https://api.telegram.org/bot{bot}/sendPhoto"
            files = {"photo": ("calendar.jpg", buf, "image/jpeg")}
            data  = {"chat_id": chat, "caption": caption, "parse_mode": "HTML"}
            r = requests.post(url, data=data, files=files, timeout=60)
            print("sendPhoto:", r.status_code, r.text[:200])
            if r.ok:
              return True
            return False

          def send_document():
            url = f"https://api.telegram.org/bot{bot}/sendDocument"
            buf.seek(0)
            files = {"document": ("calendar.jpg", buf, "image/jpeg")}
            data  = {"chat_id": chat, "caption": caption, "parse_mode": "HTML"}
            r = requests.post(url, data=data, files=files, timeout=60)
            print("sendDocument:", r.status_code, r.text[:200])
            r.raise_for_status()

          if not send_photo():
            send_document()
          PY


      - name: Done
        run: echo "‚úÖ Flujo completado"
